package hr.fer.zemris.java.custom.scripting.parser;

import hr.fer.zemris.java.custom.scripting.elems.*;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexer;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptLexerState;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptToken;
import hr.fer.zemris.java.custom.scripting.lexer.SmartScriptTokenType;
import hr.fer.zemris.java.custom.scripting.nodes.*;

import java.util.*;
import java.util.regex.Pattern;

/**
 * The parser for the Smart scripting language.
 *
 * @author Marko LazariÄ‡
 *
 */
public class SmartScriptParser {

	/**
	 * The lexer used to tokenise the input text for easier parsing.
	 */
	private SmartScriptLexer lexer;

	/**
	 * The root node of the syntax tree generated by this parser.
	 */
	private DocumentNode documentNode;

	/**
	 * A RegEx to check if a string is a valid variable name.
	 */
	private static final Pattern VARIABLE_PATTERN = Pattern.compile("^[A-Za-z][A-Za-z0-9_]*$");

	/**
	 * A RegEx to check if a string is a valid function name.
	 */
	private static final Pattern FUNCTION_PATTERN = Pattern.compile("^@[A-Za-z][A-Za-z0-9_]*$");

	/**
	 * Creates a new {@link SmartScriptParser} from the input string.
	 *
	 * @param toParse the input string to parse
	 *
	 * @throws SmartScriptParserException if {@code toParse} is {@code null}
	 */
	public SmartScriptParser(String toParse) {
		if (toParse == null) {
			throw new SmartScriptParserException("Cannot parse null.");
		}

		lexer = new SmartScriptLexer(toParse);

		try {
			parse();
		}
		catch (Exception e) { // Wrap any exceptions that occur during parsing.
			throw new SmartScriptParserException(e);
		}
	}

	/**
	 * Parse the input text into a valid syntax tree based on the Smart scripting
	 * language rules.
	 *
	 * @throws SmartScriptParserException if the input text is not a valid Smart
	 *                                    scripting language script
	 */
	private void parse() {
		Stack<Node> stack = new Stack<>();

		stack.push(new DocumentNode());

		while (true) {
			SmartScriptToken token = lexer.nextToken();

			if (token.getType() == SmartScriptTokenType.EOF) {
				break;
			}
			else if (token.getType() == SmartScriptTokenType.TEXT) {
				stack.peek().addChildNode(new TextNode((String) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.TAG_START) {
				lexer.setState(SmartScriptLexerState.INSIDE_TAG);
			}
			else if (token.getType() == SmartScriptTokenType.IDENTIFIER) {
				parseTag(stack, token);
			}
			else {
				String message = String.format("Invalid token '%s'", token.getValue());

				throw new SmartScriptParserException(message);
			}
		}

		if (stack.size() != 1) {
			throw new SmartScriptParserException("Invalid number of end tags.");
		}

		documentNode = (DocumentNode) stack.pop();
	}

	/**
	 * Parse a tag name and definition into a valid node.
	 *
	 * @param stack the stack nested for loop tags
	 *
	 * @param token the token containing the tag name
	 *
	 * @throws SmartScriptParserException if it is given an invalid tag name,
	 *                                    if there are too many end tags,
	 *                                    if there are not enough end tags
	 */
	private void parseTag(Stack<Node> stack, SmartScriptToken token) {
		String identifier = (String) token.getValue();

		if (identifier.equals("=")) {
			stack.peek().addChildNode(parseEchoTag());
		}
		else if (identifier.equalsIgnoreCase("for")) {
			ForLoopNode node = parseForLoop();

			stack.peek().addChildNode(node);
			stack.push(node);
		}
		else if (identifier.equalsIgnoreCase("end")) {
			if (stack.isEmpty()) {
				throw new SmartScriptParserException("Invalid expression: too many ends");
			}

			stack.pop();

			SmartScriptToken nextToken = lexer.nextToken();

			if (nextToken.getType() != SmartScriptTokenType.TAG_END) {
				throw new SmartScriptParserException("Invalid end tag");
			}
		}
		else {
			String message = String.format("Invalid identifier '%s'.", identifier);

			throw new SmartScriptParserException(message);
		}

		lexer.setState(SmartScriptLexerState.BASIC);
	}

	/**
	 * Parse an echo tag into an {@link EchoNode}.
	 *
	 * @return the parsed {@link EchoNode}
	 *
	 * @throws SmartScriptParserException if the echo tag is not closed,
	 *                                    if it encounters an invalid token
	 */
	private EchoNode parseEchoTag() {
		Collection<Element> collection = new ArrayList<>();

		while (true) {
			SmartScriptToken token = lexer.nextToken();

			if (token.getType() == SmartScriptTokenType.EOF) {
				throw new SmartScriptParserException("Echo tag was not closed.");
			}
			else if (token.getType() == SmartScriptTokenType.TAG_END) {
				break;
			}
			else if (token.getType() == SmartScriptTokenType.DOUBLE) {
				collection.add(new ElementConstantDouble((Double) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.INTEGER) {
				collection.add(new ElementConstantInteger((Integer) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.OPERATOR) {
				collection.add(new ElementOperator((String) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.STRING) {
				collection.add(new ElementString((String) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.IDENTIFIER) {
				collection.add(parseIdentifier(token));
			}
			else {
				String message = String.format("Unknown token '%s' in echo tag.", token.getValue());

				throw new SmartScriptParserException(message);
			}
		}

		return new EchoNode(Arrays.copyOf(collection.toArray(), collection.size(), Element[].class));
	}

	/**
	 * Parses a for loop tag into an {@link ForLoopNode}.
	 *
	 * @return the parsed {@link ForLoopNode}
	 *
	 * @throws SmartScriptParserException if the for loop tag is not closed,
	 *                                    if it encounters an invalid token,
	 *                                    if it is not a valid for loop definition
	 */
	private ForLoopNode parseForLoop() {
		List<Element> collection = new ArrayList<>();

		while (true) {
			SmartScriptToken token = lexer.nextToken();

			if (token.getType() == SmartScriptTokenType.EOF) {
				throw new SmartScriptParserException("For loop tag was not closed.");
			}
			else if (token.getType() == SmartScriptTokenType.TAG_END) {
				break;
			}
			else if (token.getType() == SmartScriptTokenType.DOUBLE) {
				collection.add(new ElementConstantDouble((Double) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.INTEGER) {
				collection.add(new ElementConstantInteger((Integer) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.STRING) {
				collection.add(new ElementString((String) token.getValue()));
			}
			else if (token.getType() == SmartScriptTokenType.IDENTIFIER) {
				Element element = parseIdentifier(token);

				if (!(element instanceof ElementVariable)) {
					throw new SmartScriptParserException("Only variables are allowed in the for loop tag definition");
				}

				collection.add(element);
			}
			else {
				String message = String.format("Unknown token '%s' in for loop tag.", token.getValue());

				throw new SmartScriptParserException(message);
			}
		}

		if (collection.size() < 3 || collection.size() > 4) {
			throw new SmartScriptParserException("Invalid number of arguments in the for loop tag.");
		}
		if (!(collection.get(0) instanceof ElementVariable)) {
			throw new SmartScriptParserException("The first argument of for loop tag has to be a variable.");
		}

		if (collection.size() == 3) {
			return new ForLoopNode((ElementVariable) collection.get(0), collection.get(1), collection.get(2), null);
		}

		return new ForLoopNode((ElementVariable) collection.get(0), collection.get(1), collection.get(2), collection.get(3));
	}

	/**
	 * Parses an identifier {@link SmartScriptToken} into either an {@link ElementFunction} or an {@link ElementVariable}.
	 *
	 * @param token the identifier token to parse
	 * @return the element generated by parsing the identifier token
	 *
	 * @see #FUNCTION_PATTERN
	 * @see #VARIABLE_PATTERN
	 */
	private Element parseIdentifier(SmartScriptToken token) {
		String identifier = (String) token.getValue();

		if (FUNCTION_PATTERN.matcher(identifier).find()) {
			return new ElementFunction(identifier.substring(1));
		}
		else if (VARIABLE_PATTERN.matcher(identifier).find()) {
			return new ElementVariable(identifier);
		}
		else {
			String message = String.format("Invalid identifier '%s'.", identifier);

			throw new SmartScriptParserException(message);
		}
	}

	/**
	 * Returns the root of the syntax tree.
	 *
	 * @return the root of the syntax tree
	 */
	public DocumentNode getDocumentNode() {
		return documentNode;
	}
}
